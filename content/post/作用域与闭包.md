---
title: 作用域与闭包
date: 2021-04-21 19:43:44
categories:
tags: [JavaScript,闭包,ES6]
---

## 作用域

全局作用域、函数作用域、块级作用域

作用域链会向上查找，找到全局window时中止==>not defined；函数被执行后其环境变量将从内存中删除，函数每次调用会创建一个新作用域。

如果子函数将被使用时，父级环境将保留，不会被释放。===闭包

块级作用域-ES6中添加的，使用let/const 定义的具有块级作用域，var没有块级作用域

<!--more-->

## 闭包

- 保护私有上下文中的私有变量”和外界互不影响。

- 私有上下文中的“私有变量”和“值”都会被保存起来，可以供其下级上下文中使用。
- 如果使用闭包，会导致栈内存太大，页面渲染变慢，性能受到影响，所以在项目中需要合理应用闭包。

- 模块化开发

##### 惰性调用：条件判断只执行一次，以后不在进行判断

##### 柯里化：预处理思想，使用闭包形成一个不被释放的上下文，把一些信息存储起来,以后基于作用域链，访问到事先存储的信息，然后进行相关的处理

## this指向

this,函数的执行主体(不等价于执行上下文),取决于谁把这个函数执行的。大体上把this执行主体分为以下几类：

- 事件绑定中的this
- 普通函数执行中的this
- 箭头函数执行中的this
- 构造函数中的 this
- 基于call/apply/bind强制改变中的this

**事件绑定中**的this指向除了IE的attachEvent方式为window外，都是指向当前侦听的DOM对象；普通函数执行中，**非严格模式**下，this指向*window*，**严格模式**下，指向为undefined，**对象中**函数的this指向调用该函数的对象，**对象调用**在全局下就是*window*；**闭包中**的this一般都是指向*window*；**回调函数中**的this一般指向*window*；**自执行函数中**的this指向*window*；**箭头函数中**没有自己的this，所用的this都是所处上下文中的this---用来保留上下文this指向；

- call

- apply

- bind

call和apply都是立即执行函数，函数.call(指向对象,[...参数])，实现思路：先给参数1添加一个属性方法并且让这个属性值赋值为函数，执行自定义属性方法，删除刚刚添加的自定义属性方法； 

`call`执行的函数，如果有参数，以逗号为间隔一个个传入，`apply`执行时，如果函数有参数，以`数组形式`传入。在**非严格模式**下，`call`方法传入null/undefined或者不传，this指向会变成window，**严格模式**下，写谁指向谁，如果指向对象为空，则指向undefined；`bind`调用的方法不会立即执行，指挥给预先处理好，等待被执行，如果函数有参数，则和call的参数传递一样；*call的性能高于apply*；